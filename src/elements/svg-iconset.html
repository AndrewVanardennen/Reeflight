<script>
class SvgIconset extends HTMLElement {
  static get is() {
    return 'svg-iconset';
  }
  static get observedAttributes() {
    return ['name'];
  }
  constructor() {
    super();
  }
  connectedCallback() {
    this.style.display = 'none';
  }
  get name() {
    return this._name;
  }
  get theme() {
    return this.getAttribute('theme') || 'light';
  }
  get size() {
    return this.getAttribute('size') || 24;
  }
  set name(value) {
    this._name = value;
    window.svgIconSet = window.svgIconSet || {};
    window.svgIconSet[value] = {host: this, theme: this.theme};
    window.dispatchEvent(new CustomEvent('svg-iconset-added'));
  }
  attributeChangedCallback(name, oldVal, newVal) {
    if (oldVal !== newVal) {
      this[name] = newVal;
    }
  }
  /**
   * Applies an icon to given element
   * @param {HTMLElement} element the element appending the icon to
   * @param {string} icon The name of the icon to show
   */
  applyIcon(element, icon) {
    element = element.root || element;
    this.removeIcon(element);
    this._cloneIcon(icon).then(icon => {
      element.insertBefore(icon, element.childNodes[0]);
      element._iconSetIcon = icon
    });
  }
  /**
   * Remove an icon from the given element by undoing the changes effected
   * by `applyIcon`.
   *
   * @param {Element} element The element from which the icon is removed.
   */
  removeIcon(element) {
    // Remove old svg element
    element = element.root || element;
    if (element._iconSetIcon) {
      element.removeChild(element._iconSetIcon);
      element._iconSetIcon = null;
    }
  }
  /**
   * Produce installable clone of the SVG element matching `id` in this
   * iconset, or `undefined` if there is no matching element.
   *
   * @return {Element} Returns an installable clone of the SVG element
   * matching `id`.
   */
  _cloneIcon(id) {
    return new Promise((resolve, reject) => {
      // create the icon map on-demand, since the iconset itself has no discrete
      // signal to know when it's children are fully parsed
      try {
        this._icons = this._icons || this._createIconMap();
        let svgClone = this._prepareSvgClone(this._icons[id], this.size);
        resolve(svgClone);
      } catch (error) {
        reject(error);
      }
    });
  }
  // TODO: Update icon-map on child changes
  /**
   * Create a map of child SVG elements by id.
   *
   * @return {!Object} Map of id's to SVG elements.
   */
  _createIconMap() {
    var icons = Object.create(null);
    this.querySelectorAll('[id]')
      .forEach(icon => {
        icons[icon.id] = icon;
      });
    return icons;
  }
  _prepareSvgClone(sourceSvg, size) {
    if (sourceSvg) {
      var content = sourceSvg.cloneNode(true),
          svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg'),
          viewBox = content.getAttribute('viewBox') || '0 0 ' + size + ' ' + size,
          cssText = 'pointer-events: none; display: block; width: 100%; height: 100%;';
      svg.setAttribute('viewBox', viewBox);
      svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
      svg.style.cssText = cssText;
      svg.appendChild(content).removeAttribute('id');
      return svg;
    }
    return null;
  }
}
customElements.define(SvgIconset.is, SvgIconset);
</script>
