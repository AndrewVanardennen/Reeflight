<link rel="import" href="../bower_components/paper-progress/paper-progress.html">
<link rel="import" href="../bower_components/paper-styles/color.html">
<script>
/**
 * ReefSlider
 * @extends HTMLElement
 */
  class ReefSlider extends HTMLElement {

    /**
     * observedAttributes
     */
    static get observedAttributes() {
      return ['value'];
    }

    /**
     * Creates shadowRoot & binds methods
     */
    constructor() {
      super();
      this.root = this.attachShadow({mode: 'open'});
      this._mousedown = this._mousedown.bind(this);
      this._mouseup = this._mouseup.bind(this);
      this._click = this._click.bind(this);
    }

    /**
     * @param {Number} value
     */
    set value(value) {
      this.setAttribute('value', value);
    }

    /**
     * @param {Number} value
     */
    set min(value) {
      this.setAttribute('min', value);
    }

    /**
     * @param {Number} value
     */
    set max(value) {
      this.setAttribute('max', value);
    }

    /**
     * @param {Number} value
     */
    set lastValue(value) {
      this._lastValue = value;
    }

    /**
     * @return {Number} attributeValue or 0
     */
    get value() {
      return this.getAttribute('value') || 0;
    }

    /**
     * @return {Number} attributeValue or 0
     */
    get min() {
      return this.getAttribute('min') || 0;
    }

    /**
     * @return {Number} attributeValue or 100
     */
    get max() {
      return this.getAttribute('max') || 100;
    }

    /**
     * @return {Number} _lastValue or 0
     */
    get lastValue() {
      return this._lastValue || 0;
    }

    /**
     * @return {Boolean} true when square is set else false
     */
    get square() {
      return this.hasAttribute('square');
    }

    /**
     * Runs when an attribute set in observedAttributes changes
     * @param {String} name name of the attribute that changed
     * @param {String} oldVal Last known value
     * @param {String} newVal Current value
     */
    attributeChangedCallback(name, oldVal, newVal) {
      if (oldVal !== newVal) {
        this[name] = newVal;
        this._updatePaperProgressAttribute(name, newVal);
        if (name === 'value') {
          newVal *= 2;
          newVal += 8;
          requestAnimationFrame(() => {
            this.sliderKnob.style.transform = 'translateX(' + newVal + 'px)';
          });
        }
      }
    }
    // TODO: Don't rerun connectedCallback, create other method ...
    /**
     * Runs when inserted in document,
     * Stamps innerHTML, set's up eventListeners
     * @return {method} connectedCallback (when paper-progress isn't ready)
     */
    connectedCallback() {
      this.root.innerHTML = `<style>
      :host {
        display: flex;
        flex-direction: row;
        align-items: center;
        height: 16px;
        padding: 12px;
        cursor: pointer;
        --reef-slider-container-color: var(--paper-grey-300);
        --reef-slider-color: var(--paper-cyan-700);
        --reef-slider-knob-color: var(--paper-amber-a700);
      }
      paper-progress {
        --paper-progress-container-color: var(--reef-slider-container-color);
        --paper-progress-active-color: var(--reef-slider-color);
      }
      .slider-knob {
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: var(--reef-slider-knob-color);
        transform: translateX(8px);
        z-index: 10;
      }
      :host[square] .slider-knob {
        border-radius: 3px;
      }
      </style>
        <div class="slider-knob"></div>
        <paper-progress></paper-progress>
      `;
      // Needed for tabbing
      this.tabIndex = 0;
      // create paperProgress
      this.paperProgress = this._qs(this, 'paper-progress');
      if (this.paperProgress === null) {
        return setTimeout(() => {
          this.connectedCallback();
        }, 10);
      }
      this.sliderKnob = this._qs(this, '.slider-knob');
      // setup event listeners
      this.addEventListener('mousedown', this._mousedown);
      this.addEventListener('mouseup', this._mouseup);
      this.addEventListener('click', this._click);

      // set paper-progress attributes
      this.paperProgress.max = this.max;
      this.paperProgress.min = this.min;

      this._qs(this.paperProgress, '#primaryProgress').style.height = '4px';
    }

    /**
     * @param {HTMLElement} target
     * @param {String} query
     * @return {HTMLElement} target.root.querySelector(query)
     */
    _qs(target, query) {
      return target.root.querySelector(query);
    }
    /**
     * @param {String} name
     * @param {String|Number|Object|Array} value
     */
    _updatePaperProgressAttribute(name, value) {
      requestAnimationFrame(() => {
        this.paperProgress[name] = value;
      });
    }
    /**
     * @param {Number} x current value
     * @param {Number} _x previous value of x
     * @return {Number} result
     */
    _calculateChange(x, _x) {
      let result = Number();
      if (_x < x) {
        x -= _x;
        result = x;
      } else if (_x > x) {
        _x -= x;
        result = _x;
      }
      return result;
    }

    /**
     * Updates the value
     */
    _mouseup() {
      event.preventDefault();
      let value = this._calculateChange(event.clientX, this.startX);
      let progressValue = this._qs(this, 'paper-progress').value;

      if (event.clientX < this.startX) {
        this.value = this._between((progressValue - (value / 2)), 0, 100);
      } else if(event.clientX > this.startX) {
        this.value = this._between((progressValue + (value / 2)), 0, 100);
      }
      this.lastValue = this.value;
    }

    /**
     * Sets startX for calculating change
     * @param {Object} event
     */
    _mousedown(event) {
      event.preventDefault();
      this.startX = event.clientX;
    }

    /**
     * Updates the value
     * @param {Object} event
     */
    _click(event) {
      event.preventDefault();
      let clientLeft = this.getBoundingClientRect().left;
      this.value = this._between(
        ((event.clientX - clientLeft - 28) / 2), 0, 100);
    }

    /**
     * @param {Number} value The value to check
     * @param {Number} min The min allowed value to return
     * @param {Number} max The max allowed value to return
     * @return {Number} between min and max, min or max
     */
    _between(value, min, max) {
      return (Math.min(max, Math.max(min, value)));
    }
  }
  customElements.define('reef-slider', ReefSlider);
</script>
